<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Inventory Solver</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&family=MedievalSharp&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100vh;
            margin: 0;
            padding: 0;
        }
        body {
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            height: 100vh;
            position: relative;
            overflow-x: hidden;
            overflow-y: overlay;
        }
        @supports not (overflow-y: overlay) {
            body { overflow-y: scroll; }
        }
        .fantasy-heading {
            font-family: 'Cinzel Decorative', 'MedievalSharp', cursive, fantasy;
            letter-spacing: 2px;
            text-shadow: 0 2px 8px #fff7, 0 0px 32px #a0f, 0 0 2px #fff;
        }
        .fantasy-panel {
            background: linear-gradient(120deg, #fff8, #e0c3fc 80%, #8ec5fc 100%);
            box-shadow: 0 4px 32px 0 #a0f4, 0 1.5px 8px #fff8;
            border-radius: 1.5rem;
            border: 2px solid #a0f6;
        }
        .glow-btn {
            box-shadow: 0 0 12px 2px #a0f8, 0 0 32px 0 #fff6;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .glow-btn:hover {
            transform: scale(1.07);
            box-shadow: 0 0 32px 8px #fff, 0 0 64px 0 #a0f;
        }
        .grid-cell {
            width: 100%; height: 100%;
            transition: background 0.3s, box-shadow 0.3s;
        }
        .grid-cell.bg-blue-500 {
            box-shadow: 0 0 16px 4px #6a11cb88, 0 0 32px 0 #fff8;
            animation: pulseCell 0.7s;
        }
        @keyframes pulseCell {
            0% { box-shadow: 0 0 0 0 #6a11cb44; }
            70% { box-shadow: 0 0 16px 8px #6a11cbcc; }
            100% { box-shadow: 0 0 16px 4px #6a11cb88; }
        }
        .sparkle {
            position: absolute;
            pointer-events: none;
            width: 8px; height: 8px;
            border-radius: 50%;
            background: radial-gradient(circle, #fff 60%, #a0f 100%);
            opacity: 0.7;
            animation: sparkleMove 6s linear infinite;
        }
        @keyframes sparkleMove {
            0% { opacity: 0; transform: scale(0.5) translateY(0); }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { opacity: 0; transform: scale(1.2) translateY(-120vh); }
        }
        #sparkle-container {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 0;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">
    <div id="sparkle-container"></div>
    <div class="flex w-full max-w-5xl fantasy-panel shadow-lg rounded-lg overflow-hidden">
        <!-- Sidebar -->
        <div class="w-80 bg-white/80 p-4 border-r border-gray-200 fantasy-panel flex flex-col h-full">
            <!-- Grid Settings -->
            <div class="mb-4 pb-4 border-b border-gray-300">
                <h2 class="text-lg font-bold mb-2 fantasy-heading">Grid Settings</h2>
                <div class="flex items-center mb-2">
                    <label class="mr-2">Rows:</label>
                    <input id="rows-input" type="number" min="1" value="5" class="w-16 border rounded px-2 py-1">
                </div>
                <div class="flex items-center mb-2">
                    <label class="mr-2">Columns:</label>
                    <input id="cols-input" type="number" min="1" value="5" class="w-16 border rounded px-2 py-1">
                </div>
                <div class="flex items-center mb-4">
                    <input id="allow-rotation" type="checkbox" class="mr-2" checked>
                    <label for="allow-rotation">Allow item rotation</label>
                </div>
                <button id="update-grid" class="w-full bg-blue-500 text-white rounded py-2 hover:bg-blue-600 glow-btn">Update Grid</button>
            </div>
            <!-- Items -->
            <div class="flex-1 flex flex-col pb-4 border-b border-gray-300">
                <div class="flex items-center justify-between mb-2">
                    <h2 class="text-lg font-bold fantasy-heading">Items</h2>
                <div class="flex gap-2">
                        <button id="add-shape" class="bg-blue-500 text-white rounded px-3 py-1 hover:bg-blue-600 glow-btn text-sm">Add Shape</button>
                        <button id="delete-preset" class="bg-red-500 text-white rounded px-3 py-1 hover:bg-red-600 glow-btn text-sm">Delete Preset</button>
                    </div>
                </div>
                <ul id="item-list" class="border rounded max-h-64 overflow-y-auto"></ul>
            </div>
            <!-- Solve Actions -->
            <div class="pt-4 pb-2 border-b border-gray-300 flex flex-col gap-2">
                <div class="flex gap-2">
                    <button id="solve-grid" class="flex-1 bg-blue-500 text-white rounded py-2 hover:bg-blue-600 glow-btn text-base font-semibold">Solve Grid</button>
                    <button id="clear-solve" class="flex-1 bg-gray-400 text-white rounded py-2 hover:bg-gray-500 glow-btn text-base">Clear Solve</button>
                </div>
            </div>
            <!-- Utility Actions -->
            <div class="pt-4 flex flex-col gap-2">
                <div class="flex gap-2">
                    <button id="reset-all" class="flex-1 bg-yellow-500 text-white rounded py-2 hover:bg-yellow-600 glow-btn">Reset All</button>
                    <button id="clear-cookie" class="flex-1 bg-red-700 text-white rounded py-2 hover:bg-red-800 glow-btn">Clear Cookie</button>
                </div>
                <div class="mt-2">
                    <label class="block text-xs mb-1">Import Presets (JSON):</label>
                    <input id="import-presets" type="file" accept="application/json" class="w-full text-xs" />
                    <button id="export-presets" class="w-full mt-2 bg-green-500 text-white rounded py-2 hover:bg-green-600 glow-btn text-xs">Save Presets (JSON)</button>
                </div>
            </div>
        </div>
        <!-- Main Panel -->
        <div class="flex-1 p-4 fantasy-panel">
            <div class="flex items-center justify-between bg-gray-50/80 p-2 mb-2 rounded-lg shadow fantasy-panel">
                <h2 class="text-lg font-bold fantasy-heading">Inventory Grid</h2>
                <span class="text-sm text-gray-700">Click cells to toggle disable (red)</span>
            </div>
            <canvas id="grid-canvas" class="w-full h-[500px] rounded-xl shadow-lg border-2 border-blue-300"></canvas>
        </div>
    </div>

    <!-- Custom Shape Modal -->
    <div id="custom-shape-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center hidden z-50">
        <div class="bg-white/90 p-6 rounded-2xl w-96 shadow-2xl fantasy-panel">
            <h2 class="text-lg font-bold mb-4 fantasy-heading">Create Custom Shape</h2>
            <div class="mb-4">
                <div class="flex items-center mb-2">
                    <label class="mr-2">Rows:</label>
                    <input id="custom-rows" type="number" min="1" max="10" value="3" class="w-16 border rounded px-2 py-1">
                </div>
                <div class="flex items-center mb-2">
                    <label class="mr-2">Cols:</label>
                    <input id="custom-cols" type="number" min="1" max="10" value="3" class="w-16 border rounded px-2 py-1">
                </div>
                <button id="update-custom-grid" class="bg-blue-500 text-white rounded py-2 px-4 hover:bg-blue-600 glow-btn">Update</button>
            </div>
            <div id="custom-grid" class="border rounded p-2 mb-4 grid gap-1"></div>
            <div class="mb-4">
                <label class="block mb-1">Preset Name:</label>
                <input id="preset-name" type="text" class="w-full border rounded px-2 py-1">
                <label class="flex items-center mt-2">
                    <input id="save-preset" type="checkbox" class="mr-2">
                    <span>Save as Preset</span>
                </label>
            </div>
            <div class="flex gap-2">
                <button id="cancel-custom" class="flex-1 bg-gray-500 text-white rounded py-2 hover:bg-gray-600 glow-btn">Cancel</button>
                <button id="create-custom" class="flex-1 bg-blue-500 text-white rounded py-2 hover:bg-blue-600 glow-btn">Create</button>
            </div>
        </div>
    </div>

    <script>
        class GridInventorySolver {
            constructor() {
                this.gridRows = 5;
                this.gridCols = 5;
                this.items = [];
                this.presets = {};
                this.predefinedShapes = {};
                this.disabledCells = Array(this.gridRows).fill().map(() => Array(this.gridCols).fill(0));
                this.solution = null;
                this.selectedItems = new Set();
                this.colors = [
                    "#FF5733", "#33FF57", "#3357FF", "#F3FF33", "#FF33F6", "#33FFF6", "#F633FF", "#57FF33", "#FF3357", "#33F3FF",
                    "#FF8C00", "#8A2BE2", "#7FFF00", "#DC143C", "#00FFFF", "#FF1493", "#FFD700", "#4B0082", "#20B2AA", "#32CD32",
                    "#FF4500", "#2E8B57", "#4682B4", "#8B0000", "#00CED1", "#9400D3", "#008080", "#FF6347", "#ADFF2F", "#8B4513",
                    "#E67E22", "#1ABC9C", "#9B59B6", "#E74C3C", "#2ECC71", "#3498DB", "#F1C40F", "#E84393", "#00B894", "#6C5CE7",
                    "#00CEC9", "#FD79A8", "#636E72", "#D35400", "#00A8FF", "#9C88FF", "#FBC531", "#4CD137", "#487EB0", "#B33771",
                    "#3B3B98", "#F8EFBA", "#574B90", "#F97F51", "#1B9CFC", "#55E6C1", "#B33771", "#3B3B98", "#FD7272", "#25CCF7"
                ];
                this.usedColorIndex = 0;
                
                this.canvas = document.getElementById('grid-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.itemList = document.getElementById('item-list');
                this.customModal = document.getElementById('custom-shape-modal');
                this.customGrid = document.getElementById('custom-grid');
                this.importPresetsInput = document.getElementById('import-presets');
                this.allowRotationInput = document.getElementById('allow-rotation');
                this.allowRotation = true;
                this.loadPredefinedShapes();
                this.loadData();
                this.setupEventListeners();
                this.drawGrid();
            }

            async loadPredefinedShapes() {
                try {
                    const res = await fetch('predefined_shapes.json');
                    if (res.ok) {
                        this.predefinedShapes = await res.json();
                    }
                } catch (e) {
                    this.predefinedShapes = {};
                }
            }

            setupEventListeners() {
                document.getElementById('update-grid').addEventListener('click', () => this.updateGrid());
                document.getElementById('add-shape').addEventListener('click', (e) => this.showAddShapeMenu(e));
                document.getElementById('delete-preset').addEventListener('click', (e) => this.showDeletePresetMenu(e));
                document.getElementById('solve-grid').addEventListener('click', () => this.solveGrid());
                document.getElementById('clear-solve').addEventListener('click', () => this.clearSolve());
                document.getElementById('reset-all').addEventListener('click', () => this.resetAll());
                document.getElementById('clear-cookie').addEventListener('click', () => this.clearAllData());
                document.getElementById('update-custom-grid').addEventListener('click', () => this.updateCustomGrid());
                document.getElementById('cancel-custom').addEventListener('click', () => this.closeCustomModal());
                document.getElementById('create-custom').addEventListener('click', () => this.createCustomShape());
                this.canvas.addEventListener('click', (e) => this.onCanvasClick(e));
                this.itemList.addEventListener('click', (e) => this.onItemClick(e));
                this.importPresetsInput.addEventListener('change', (e) => this.importPresets(e));
                document.getElementById('export-presets').addEventListener('click', () => this.exportPresets());
                window.addEventListener('resize', () => this.drawGrid());
                this.allowRotationInput.addEventListener('change', () => {
                    this.allowRotation = this.allowRotationInput.checked;
                    this.saveData();
                });
            }

            drawGrid() {
                this.canvas.width = this.canvas.clientWidth;
                this.canvas.height = this.canvas.clientHeight;
                const cellWidth = this.canvas.width / this.gridCols;
                const cellHeight = this.canvas.height / this.gridRows;

                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                for (let r = 0; r < this.gridRows; r++) {
                    for (let c = 0; c < this.gridCols; c++) {
                        const x = c * cellWidth;
                        const y = r * cellHeight;
                        this.ctx.fillStyle = this.disabledCells[r][c] === -1 ? '#ffcccc' : '#ffffff';
                        this.ctx.fillRect(x, y, cellWidth, cellHeight);
                        this.ctx.strokeStyle = '#d1d5db';
                        this.ctx.strokeRect(x, y, cellWidth, cellHeight);
                    }
                }

                if (this.solution) {
                    this.displaySolution();
                } else if (typeof this.previewingIndex === 'number' && this.items[this.previewingIndex]) {
                    this.previewItem(this.items[this.previewingIndex]);
                }
            }

            showAddShapeMenu(event) {
                const menu = document.createElement('div');
                menu.className = 'absolute bg-white border rounded shadow-lg p-2';
                menu.style.left = `${event.clientX}px`;
                menu.style.top = `${event.clientY}px`;
                menu.style.zIndex = 1000;
                // Search bar (sticky)
                const searchInput = document.createElement('input');
                searchInput.type = 'text';
                searchInput.placeholder = 'Search shape or preset...';
                searchInput.className = 'w-full px-2 py-1 border rounded text-sm';
                searchInput.style.position = 'sticky';
                searchInput.style.top = '0';
                searchInput.style.background = 'white';
                menu.appendChild(searchInput);
                // Container for list (scrollable)
                const listDiv = document.createElement('div');
                listDiv.style.maxHeight = '350px';
                listDiv.style.overflowY = 'auto';
                listDiv.className = 'mt-2';
                menu.appendChild(listDiv);

                function renderList(filter = '') {
                    listDiv.innerHTML = '';
                    // Custom shape always on top
                    if ('custom shape'.includes(filter.toLowerCase())) {
                        const customDiv = document.createElement('div');
                        customDiv.className = 'px-4 py-2 hover:bg-gray-100 cursor-pointer';
                        customDiv.textContent = 'Custom Shape';
                        customDiv.onclick = () => { app.showCustomModal(); document.body.removeChild(menu); };
                        listDiv.appendChild(customDiv);
                    }
                    // Predefined shapes
                    let foundPredefined = false;
                    for (const [name, shape] of Object.entries(app.predefinedShapes)) {
                        if (name.toLowerCase().includes(filter.toLowerCase())) {
                            foundPredefined = true;
                            const div = document.createElement('div');
                            div.className = 'px-4 py-2 hover:bg-gray-100 cursor-pointer';
                            div.textContent = name;
                            div.onclick = () => { app.addPredefinedItem(name); document.body.removeChild(menu); };
                            listDiv.appendChild(div);
                        }
                    }
                    if (foundPredefined) listDiv.appendChild(document.createElement('hr'));
                    // Presets
                    for (const name of Object.keys(app.presets)) {
                        if (name.toLowerCase().includes(filter.toLowerCase())) {
                            const div = document.createElement('div');
                            div.className = 'px-4 py-2 hover:bg-gray-100 cursor-pointer';
                            div.textContent = `Preset: ${name}`;
                            div.onclick = () => { app.addPresetItem(name); document.body.removeChild(menu); };
                            listDiv.appendChild(div);
                        }
                    }
                }
                renderList();
                searchInput.addEventListener('input', (e) => {
                    renderList(e.target.value);
                });

                document.body.appendChild(menu);
                setTimeout(() => {
                    document.addEventListener('click', function handler(e) {
                        if (!menu.contains(e.target)) {
                            menu.remove();
                            document.removeEventListener('click', handler);
                        }
                    });
                }, 0);
            }

            showDeletePresetMenu(event) {
                if (Object.keys(this.presets).length === 0) {
                    alert('No presets to delete.');
                    return;
                }
                const menu = document.createElement('div');
                menu.className = 'absolute bg-white border rounded shadow-lg';
                menu.style.left = `${event.clientX}px`;
                menu.style.top = `${event.clientY}px`;

                for (const name of Object.keys(this.presets)) {
                    menu.innerHTML += `<div class="px-4 py-2 hover:bg-gray-100 cursor-pointer" onclick="app.deletePreset('${name}'); document.body.removeChild(this.parentElement)">${name}</div>`;
                }

                document.body.appendChild(menu);
                // Remove menu on outside click
                setTimeout(() => {
                    document.addEventListener('click', function handler(e) {
                        if (!menu.contains(e.target)) {
                            menu.remove();
                            document.removeEventListener('click', handler);
                        }
                    });
                }, 0);
            }

            addPredefinedItem(shapeName) {
                const shape = this.predefinedShapes[shapeName];
                const name = `${shapeName} ${this.items.length + 1}`;
                const color = this.randomColor(this.items.length);
                this.items.push({ name, shape, color });
                this.solution = null;
                this.updateItemList();
                this.saveData();
                this.drawGrid();
            }

            addPresetItem(presetName) {
                const shape = this.presets[presetName];
                const name = `${presetName} ${this.items.length + 1}`;
                const color = this.randomColor(this.items.length);
                this.items.push({ name, shape, color });
                this.solution = null;
                this.updateItemList();
                this.saveData();
                this.drawGrid();
            }

            deletePreset(presetName) {
                delete this.presets[presetName];
                this.saveData();
                alert(`Preset '${presetName}' deleted.`);
                // Update UI after deletion
                this.drawGrid();
            }

            updateItemList() {
                this.itemList.innerHTML = '';
                this.items.forEach((item, index) => {
                    // List item container
                    const li = document.createElement('li');
                    li.className = 'px-2 py-1 flex items-center justify-between';
                    // Name
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = item.name;
                    nameSpan.dataset.index = index;
                    nameSpan.addEventListener('mouseenter', () => {
                        this.previewingIndex = index;
                        this.drawGrid();
                    });
                    nameSpan.addEventListener('mouseleave', () => {
                        this.previewingIndex = null;
                        this.drawGrid();
                    });
                    // Icon group (right)
                    const iconGroup = document.createElement('span');
                    iconGroup.className = 'flex gap-2 items-center ml-2';
                    // Duplicate icon
                    const duplicate = document.createElement('span');
                    duplicate.textContent = 'ðŸ“„';
                    duplicate.className = 'cursor-pointer text-lg align-middle hover:text-blue-600 transition-colors';
                    duplicate.title = 'Duplicate';
                    duplicate.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.duplicateItem(index);
                    });
                    // Trash can icon
                    const trash = document.createElement('span');
                    trash.textContent = 'ðŸ—‘ï¸';
                    trash.className = 'cursor-pointer text-lg align-middle hover:text-red-600 transition-colors';
                    trash.title = 'Delete';
                    trash.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.deleteItem(index);
                    });
                    iconGroup.appendChild(duplicate);
                    iconGroup.appendChild(trash);
                    li.appendChild(nameSpan);
                    li.appendChild(iconGroup);
                    this.itemList.appendChild(li);
                    // Divider
                    if (index < this.items.length - 1) {
                        const hr = document.createElement('hr');
                        hr.className = 'my-1 border-gray-300';
                        this.itemList.appendChild(hr);
                    }
                });
            }

            onItemClick(event) {
                // No-op for preview system on hover
            }

            previewItem(item) {
                const shape = item.shape;
                const color = item.color;
                const cellWidth = this.canvas.width / this.gridCols;
                const cellHeight = this.canvas.height / this.gridRows;
                const startRow = Math.max(0, Math.floor((this.gridRows - shape.length) / 2));
                const startCol = Math.max(0, Math.floor((this.gridCols - shape[0].length) / 2));

                this.ctx.save();
                this.ctx.globalAlpha = 0.5;
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[0].length; c++) {
                        if (shape[r][c] === 1) {
                            this.ctx.fillStyle = color;
                            this.ctx.fillRect((startCol + c) * cellWidth, (startRow + r) * cellHeight, cellWidth, cellHeight);
                        }
                    }
                }
                this.ctx.globalAlpha = 1.0;
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[0].length; c++) {
                        if (shape[r][c] === 1) {
                            this.ctx.strokeStyle = '#222';
                            this.ctx.lineWidth = 2;
                            this.ctx.strokeRect((startCol + c) * cellWidth, (startRow + r) * cellHeight, cellWidth, cellHeight);
                        }
                    }
                }
                this.ctx.restore();
            }

            deleteSelected() {
                const indices = Array.from(this.selectedItems).sort((a, b) => b - a);
                indices.forEach(index => this.items.splice(index, 1));
                this.selectedItems.clear();
                this.updateItemList();
                this.drawGrid();
                this.saveData();
            }

            deleteItem(index) {
                this.items.splice(index, 1);
                this.previewingIndex = null;
                this.solution = null;
                this.updateItemList();
                this.drawGrid();
                this.saveData();
            }

            // Helper to get next available numbered name for a base name
            getNextItemName(baseName) {
                // Find all items with the same base name and a number
                let maxNum = 0;
                const regex = new RegExp(`^${baseName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')} (\\d+)$`);
                for (const item of this.items) {
                    const match = item.name.match(regex);
                    if (match) {
                        const num = parseInt(match[1]);
                        if (num > maxNum) maxNum = num;
                    }
                }
                return `${baseName} ${maxNum + 1}`;
            }
            duplicateItem(index) {
                const item = this.items[index];
                // Try to extract base name and number
                let baseName = item.name;
                let match = item.name.match(/^(.*) (\d+)$/);
                if (match) {
                    baseName = match[1];
                }
                const newName = this.getNextItemName(baseName);
                // Deep copy shape array
                const newShape = item.shape.map(row => [...row]);
                // Pick color not same as neighbors
                const color = this.randomColor(index + 1);
                const newItem = {
                    name: newName,
                    shape: newShape,
                    color: color
                };
                this.items.splice(index + 1, 0, newItem);
                this.solution = null;
                this.updateItemList();
                this.drawGrid();
                this.saveData();
            }

            randomColor() {
                // Use each color in this.colors once before repeating
                if (this.usedColorIndex < this.colors.length) {
                    return this.colors[this.usedColorIndex++];
                } else {
                    // After all colors are used, pick randomly
                return this.colors[Math.floor(Math.random() * this.colors.length)];
                }
            }

            updateGrid() {
                const newRows = parseInt(document.getElementById('rows-input').value);
                const newCols = parseInt(document.getElementById('cols-input').value);
                if (newRows <= 0 || newCols <= 0 || isNaN(newRows) || isNaN(newCols)) {
                    alert('Please enter positive integers.');
                    return;
                }
                const newDisabled = Array(newRows).fill().map(() => Array(newCols).fill(0));
                const minRows = Math.min(this.gridRows, newRows);
                const minCols = Math.min(this.gridCols, newCols);
                for (let r = 0; r < minRows; r++) {
                    for (let c = 0; c < minCols; c++) {
                        newDisabled[r][c] = this.disabledCells[r][c];
                    }
                }
                this.gridRows = newRows;
                this.gridCols = newCols;
                this.disabledCells = newDisabled;
                this.solution = null;
                this.drawGrid();
                this.saveData();
            }

            onCanvasClick(event) {
                const cellWidth = this.canvas.width / this.gridCols;
                const cellHeight = this.canvas.height / this.gridRows;
                const col = Math.floor(event.offsetX / cellWidth);
                const row = Math.floor(event.offsetY / cellHeight);
                if (row >= 0 && row < this.gridRows && col >= 0 && col < this.gridCols) {
                    this.disabledCells[row][col] = this.disabledCells[row][col] === 0 ? -1 : 0;
                    this.solution = null;
                    this.drawGrid();
                    this.saveData();
                }
            }

            solveGrid() {
                if (this.items.length === 0) {
                    alert('Please add items to solve.');
                    return;
                }
                // Count available grid cells (not disabled)
                let available = 0;
                for (let r = 0; r < this.gridRows; r++) {
                    for (let c = 0; c < this.gridCols; c++) {
                        if (this.disabledCells[r][c] === 0) available++;
                    }
                }
                // Count total item cells needed
                let needed = 0;
                for (const item of this.items) {
                    for (const row of item.shape) {
                        for (const cell of row) {
                            if (cell === 1) needed++;
                        }
                    }
                }
                if (needed > available) {
                    alert('Not enough space in the grid for all items!');
                    return;
                }
                // Timeout logic
                const startTime = performance.now();
                const maxTime = 2000; // ms
                const timedSolver = (grid, items, itemIndex = 0) => {
                    if (performance.now() - startTime > maxTime) return 'TIMEOUT';
                    if (itemIndex >= items.length) return grid;
                    const shape = items[itemIndex].shape;
                    const maxRot = this.allowRotation ? 4 : 1;
                    for (let k = 0; k < maxRot; k++) {
                        let rotated = shape;
                        for (let i = 0; i < k; i++) {
                            rotated = this.rotateShape(rotated);
                        }
                        for (let r = 0; r <= grid.length - rotated.length; r++) {
                            for (let c = 0; c <= grid[0].length - rotated[0].length; c++) {
                                if (this.canPlaceItem(grid, rotated, r, c)) {
                                    const newGrid = grid.map(row => [...row]);
                                    for (let i = 0; i < rotated.length; i++) {
                                        for (let j = 0; j < rotated[0].length; j++) {
                                            if (rotated[i][j] === 1) {
                                                newGrid[r + i][c + j] = itemIndex + 1;
                                            }
                                        }
                                    }
                                    const result = timedSolver(newGrid, items, itemIndex + 1);
                                    if (result && result !== 'TIMEOUT') return result;
                                    if (result === 'TIMEOUT') return 'TIMEOUT';
                                }
                            }
                        }
                    }
                    return null;
                };
                let result = timedSolver(this.disabledCells.map(row => [...row]), [...this.items]);
                if (result === 'TIMEOUT') {
                    alert('Solving took too long or no solution found.');
                    this.solution = null;
                } else if (!result) {
                    alert('No solution found.');
                    this.solution = null;
                } else {
                    this.solution = result;
                }
                this.drawGrid();
                this.saveData();
            }

            backtrackingSolver(grid, items, itemIndex = 0) {
                if (itemIndex >= items.length) return grid;
                const shape = items[itemIndex].shape;
                const maxRot = this.allowRotation ? 4 : 1;
                for (let k = 0; k < maxRot; k++) {
                    let rotated = shape;
                    for (let i = 0; i < k; i++) {
                        rotated = this.rotateShape(rotated);
                    }
                    for (let r = 0; r <= grid.length - rotated.length; r++) {
                        for (let c = 0; c <= grid[0].length - rotated[0].length; c++) {
                            if (this.canPlaceItem(grid, rotated, r, c)) {
                                const newGrid = grid.map(row => [...row]);
                                for (let i = 0; i < rotated.length; i++) {
                                    for (let j = 0; j < rotated[0].length; j++) {
                                        if (rotated[i][j] === 1) {
                                            newGrid[r + i][c + j] = itemIndex + 1;
                                        }
                                    }
                                }
                                const result = this.backtrackingSolver(newGrid, items, itemIndex + 1);
                                if (result) return result;
                            }
                        }
                    }
                }
                return null;
            }

            rotateShape(shape) {
                const rows = shape.length;
                const cols = shape[0].length;
                const rotated = Array(cols).fill().map(() => Array(rows).fill(0));
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        rotated[c][rows - 1 - r] = shape[r][c];
                    }
                }
                return rotated;
            }

            canPlaceItem(grid, shape, startRow, startCol) {
                if (startRow + shape.length > grid.length || startCol + shape[0].length > grid[0].length) return false;
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[0].length; c++) {
                        if (shape[r][c] === 1 && (startRow + r >= grid.length || startCol + c >= grid[0].length || grid[startRow + r][startCol + c] !== 0)) {
                            return false;
                        }
                    }
                }
                return true;
            }

            displaySolution() {
                const cellWidth = this.canvas.width / this.gridCols;
                const cellHeight = this.canvas.height / this.gridRows;
                for (let r = 0; r < this.solution.length; r++) {
                    for (let c = 0; c < this.solution[0].length; c++) {
                        if (this.solution[r][c] > 0) {
                            const color = this.items[this.solution[r][c] - 1].color;
                            this.ctx.fillStyle = color;
                            this.ctx.fillRect(c * cellWidth, r * cellHeight, cellWidth, cellHeight);
                            this.ctx.strokeStyle = '#d1d5db';
                            this.ctx.strokeRect(c * cellWidth, r * cellHeight, cellWidth, cellHeight);
                        }
                    }
                }
            }

            showCustomModal() {
                this.customModal.classList.remove('hidden');
                this.updateCustomGrid();
            }

            closeCustomModal() {
                this.customModal.classList.add('hidden');
            }

            updateCustomGrid() {
                const rows = parseInt(document.getElementById('custom-rows').value);
                const cols = parseInt(document.getElementById('custom-cols').value);
                if (rows <= 0 || cols <= 0 || rows > 10 || cols > 10 || isNaN(rows) || isNaN(cols)) {
                    alert('Enter integers between 1 and 10.');
                    return;
                }
                this.customGrid.style.gridTemplateRows = `repeat(${rows}, 30px)`;
                this.customGrid.style.gridTemplateColumns = `repeat(${cols}, 30px)`;
                this.customGrid.innerHTML = '';
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell border bg-white';
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        cell.addEventListener('click', () => {
                            cell.classList.toggle('bg-blue-500');
                            cell.classList.toggle('bg-white');
                        });
                        this.customGrid.appendChild(cell);
                    }
                }
            }

            createCustomShape() {
                const rows = parseInt(document.getElementById('custom-rows').value);
                const cols = parseInt(document.getElementById('custom-cols').value);
                const shape = Array(rows).fill().map(() => Array(cols).fill(0));
                let hasContent = false;
                this.customGrid.querySelectorAll('.grid-cell').forEach(cell => {
                    const r = parseInt(cell.dataset.row);
                    const c = parseInt(cell.dataset.col);
                    if (cell.classList.contains('bg-blue-500')) {
                        shape[r][c] = 1;
                        hasContent = true;
                    }
                });
                if (!hasContent) {
                    alert('Create a non-empty shape.');
                    return;
                }
                const rowsWithContent = shape.map((row, i) => row.includes(1) ? i : -1).filter(i => i !== -1);
                const colsWithContent = shape[0].map((_, c) => shape.some(row => row[c] === 1) ? c : -1).filter(c => c !== -1);
                const minRow = Math.min(...rowsWithContent);
                const maxRow = Math.max(...rowsWithContent);
                const minCol = Math.min(...colsWithContent);
                const maxCol = Math.max(...colsWithContent);
                const trimmedShape = shape.slice(minRow, maxRow + 1).map(row => row.slice(minCol, maxCol + 1));
                const name = document.getElementById('preset-name').value.trim() || `Custom ${this.items.length + 1}`;
                const savePreset = document.getElementById('save-preset').checked;
                if (savePreset && !name) {
                    alert('Please enter a name to save as preset.');
                    return;
                }
                this.items.push({ name, shape: trimmedShape, color: this.randomColor() });
                if (savePreset) {
                    this.presets[name] = trimmedShape;
                }
                this.updateItemList();
                this.saveData();
                this.closeCustomModal();
                this.drawGrid();
            }

            saveData() {
                const data = {
                    gridRows: this.gridRows,
                    gridCols: this.gridCols,
                    disabledCells: this.disabledCells,
                    items: this.items.map(item => ({
                        name: item.name,
                        shape: item.shape,
                        color: item.color
                    })),
                    presets: this.presets,
                    solution: this.solution
                    ,allowRotation: this.allowRotation
                };
                Cookies.set('gridData', JSON.stringify(data), { expires: 365 });
            }

            loadData() {
                const data = Cookies.get('gridData');
                if (data) {
                    const parsed = JSON.parse(data);
                    this.gridRows = parsed.gridRows || 5;
                    this.gridCols = parsed.gridCols || 5;
                    this.disabledCells = parsed.disabledCells || Array(this.gridRows).fill().map(() => Array(this.gridCols).fill(0));
                    this.items = parsed.items || [];
                    this.presets = parsed.presets || {};
                    this.solution = parsed.solution || null;
                    this.allowRotation = typeof parsed.allowRotation === 'boolean' ? parsed.allowRotation : true;
                    this.allowRotationInput.checked = this.allowRotation;
                    document.getElementById('rows-input').value = this.gridRows;
                    document.getElementById('cols-input').value = this.gridCols;
                    this.updateItemList();
                }
            }

            resetAll() {
                if (!confirm('Are you sure you want to reset all items and disabled grid cells? Presets will be kept.')) return;
                this.items = [];
                this.selectedItems.clear();
                this.disabledCells = Array(this.gridRows).fill().map(() => Array(this.gridCols).fill(0));
                this.solution = null;
                this.usedColorIndex = 0;
                this.updateItemList();
                this.drawGrid();
                this.saveData();
            }

            clearAllData() {
                if (!confirm('Are you sure you want to clear ALL saved data? This will remove all items, grid, disables, and presets.')) return;
                Cookies.remove('gridData');
                this.gridRows = 5;
                this.gridCols = 5;
                this.items = [];
                this.presets = {};
                this.disabledCells = Array(this.gridRows).fill().map(() => Array(this.gridCols).fill(0));
                this.solution = null;
                this.selectedItems.clear();
                this.usedColorIndex = 0;
                document.getElementById('rows-input').value = this.gridRows;
                document.getElementById('cols-input').value = this.gridCols;
                this.updateItemList();
                this.drawGrid();
                this.saveData();
            }

            async importPresets(e) {
                const file = e.target.files[0];
                if (!file) return;
                try {
                    const text = await file.text();
                    const json = JSON.parse(text);
                    if (typeof json === 'object') {
                        Object.assign(this.presets, json);
                        this.saveData();
                        alert('Presets imported!');
                    } else {
                        alert('Invalid preset file.');
                    }
                } catch (err) {
                    alert('Failed to import presets.');
                }
            }

            exportPresets() {
                const dataStr = JSON.stringify(this.presets, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'presets.json';
                document.body.appendChild(a);
                a.click();
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }

            clearSolve() {
                this.solution = null;
                this.drawGrid();
                this.saveData();
            }
        }

        window.app = new GridInventorySolver();
    </script>
    <script>
    // Sparkle particle effect
    function createSparkle() {
        const sparkle = document.createElement('div');
        sparkle.className = 'sparkle';
        sparkle.style.left = Math.random() * 100 + 'vw';
        sparkle.style.top = '100vh';
        sparkle.style.animationDuration = (4 + Math.random() * 4) + 's';
        sparkle.style.opacity = 0.5 + Math.random() * 0.5;
        document.getElementById('sparkle-container').appendChild(sparkle);
        setTimeout(() => sparkle.remove(), 8000);
    }
    setInterval(createSparkle, 350);
    for (let i = 0; i < 12; i++) setTimeout(createSparkle, i * 300);
    </script>
</body>
</html>